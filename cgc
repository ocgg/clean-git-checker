#!/bin/bash

ROOT=$(dirname "$(realpath "$0")")
REPOS_FILE_NAME="repos_to_check.txt"
REPOS_FILE_PATH="$ROOT/$REPOS_FILE_NAME"
WARNINGS=()

RED="\e[0;31m"
YELLOW="\e[0;33m"
GREEN="\e[0;32m"
CYAN="\e[0;36m"
BOLD="\e[1;m"
NC="\e[0m"

USER_EXIT_CODE=33

print_warning() {
    echo -e "${YELLOW}WARNING: $1${NC}" >&2
}

print_warnings() {
    echo
    for message in "${WARNINGS[@]}"; do
        print_warning "$message"
    done
    echo -e "${BOLD}Your git directories list contains errors!${NC}"
    echo -e "Check the file: \e]8;;$REPOS_FILE_PATH\e\\$REPOS_FILE_PATH\e]8;;\e\\"
}

add_warning() {
    WARNINGS+=("$1")
}

check_repo_file() {
    [ -f "$REPOS_FILE_PATH" ] && return 0

    print_warning "Repo list file not found: $REPOS_FILE_PATH"
    touch "$REPOS_FILE_PATH"
    {
        echo "# - Lines beginning with '#' are ignored";
        echo "# - Empty lines are ignored";
        echo "# - Write absolute paths to your repos, one per line"
    } >> "$REPOS_FILE_PATH"
    echo
    echo "Please provide absolute paths to git directories in that file, one path a line, and retry."
    return 1
}

check_repo_dir() {
    if [[ -z "$1" || "$1" =~ ^# ]]; then
        return 1
    elif [ ! -d "$1" ]; then
        add_warning "Directory not found: $1"
        return 1
    elif ! git -C "$1" rev-parse --is-inside-work-tree > /dev/null 2>&1; then
        add_warning "Not a git repository: $1"
        return 1
    fi
    return 0
}


# NOTE: "exit" commands here just terminate the subshell from where menu() is
# called, not the entire script.
menu() {
    while true; do
        # echo -e "${YELLOW}✗ ${CYAN}${BOLD}$(basename "$(realpath .)"):${RED}${BOLD}$(git branch --show-current)${NC}"
        echo "[d]iff | [c]ommit | [cd] to repo | [i]gnore or [q]uit ?"
        read -r -p "> " action < /dev/tty
        case "$action" in
            d) git diff;;

            c)  read -r -p "Message: " msg < /dev/tty
                git add --all
                git commit -m "$msg" || exit 1
                read -r -p "Run git push ? (y/n) > " push < /dev/tty
                [ "$push" = "y" ] && git push
                break;;

            cd) echo
                echo -e "${GREEN}Opening $1 in a new session...${NC}"
                echo -e "${GREEN}'exit' or ctrl+d to come back.${NC}"
                cd "$1" || exit
                $SHELL -i
                echo
                echo -e "${GREEN}Back to clean git checker...${NC}"
                break;;

            i) break;;

            q) exit $USER_EXIT_CODE;;

            *) echo "Please type d, c, cd, i or q.";;
        esac
    done
}

check_repo_file || exit 1

while IFS= read -r repo_dir; do
    check_repo_dir "$repo_dir" || continue

    (
        cd "$repo_dir" || exit 2

        if [ -n "$(git status --porcelain)" ]; then
            # echo -e "${BOLD}Uncommitted changes detected!"
            # echo -e "${RED}UNCLEAN: $repo_dir${NC}\n"
            clear
            echo -e " ${YELLOW}✗ ${CYAN}${BOLD}$(basename "$(realpath .)"):${RED}${BOLD}$(git branch --show-current) ${YELLOW}✗${NC}"
            echo
            git status --short
            echo
            menu "$repo_dir"
        fi
    )
    output_code=$?
    [ $output_code -eq $USER_EXIT_CODE ] && exit
    [ $output_code -eq 1 ] && exit 1
done < "$REPOS_FILE_PATH"

[ ${#WARNINGS[@]} -ne 0 ] && print_warnings
